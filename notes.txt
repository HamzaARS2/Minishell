ls << $USER | ls -a | grep ft | cat -e  << l 





TODO;

    // (1) *heredoc should expand '$USER' : ()
    // (2) heredoc close when entering '\0'
    // (3) redirection not getting listed when the come before command.
    // (4) when redirection fail shouldn't continue to other redirections
    
    // (1) is dirctory with perror




    char	*cmd_expand(char *cmd, char **paths)
{
	char *check_return ;
	check_return = 0;
	if (!cmd)
		exit(0);
	check_return = check_cmd(paths, cmd);
	// system("leaks -q minishell"); //**LEAKS TEST**//=
	return (check_return); //add "/"  //add CMD
}



++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




char	*expand_cmd_path(char *path, char *cmd)

{
	char	*cmd_slash;
	char	*rtrn_path;
	int		status;

	if (!cmd[0])
		return (NULL);
	if ((ft_strchr(cmd, '/') && is_directory(cmd)) || is_directory(cmd))
		err_write("minishell: ", cmd, ": is a directory\n", 126);
	if (ft_strchr(cmd, '/'))
	{
		status = check_access(cmd);
		if (status == 2)
				err_write("minishell: ", cmd, ": No such file or directory\n", 127);
		else if (status == 1)
			err_write("minishell: ", cmd, ": Permission denied\n", 126);
		return (cmd);
	}
	if (!path)
		return (NULL);
	cmd_slash = strcombine(path, "/", false); // (|) *FREE CMD_SLASH
		////****// *FREE() (1) FREE_PATH  (2) FREE_CMD(AST->ARG)
	rtrn_path = strcombine(cmd_slash, cmd, false);
	free(cmd_slash);
	return (rtrn_path);
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


void    exec_pipe(t_ast *ast, t_executor *executor)
{
    t_context l_ctx;
    t_context r_ctx;
    int p[2];

    l_ctx = executor->ctx;
    r_ctx = executor->ctx;
    if (pipe(p) == -1)
    {
        *executor->ex_status = EXIT_FAILURE;
        perror("minishell: pipe error:");
        return ;
    }
    l_ctx.fd[STDOUT_FILENO] = p[STDOUT_FILENO];
    // if (r_ctx.close_fd != -1)
    //     close (r_ctx.close_fd);
    l_ctx.close_fd = p[STDIN_FILENO];
    executor->ctx = l_ctx;
    if (!exec_tree(ast->left, executor))
        return ;
    r_ctx.fd[STDIN_FILENO] = p[STDIN_FILENO];
    r_ctx.close_fd = p[STDOUT_FILENO];
    executor->ctx = r_ctx;
    exec_tree(ast->right, executor);
    close(p[STDIN_FILENO]);
    close(p[STDOUT_FILENO]);
}


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


